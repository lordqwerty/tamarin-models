/*
 * Authors: Jorden Whitefield, Liqun Chen, Frank Kargl, Andrew Paverd,
 * Steve Schneider, Helen Treharne, and Stephan Wesemeyer
 *
 * References:
 * REWIRE Revocation Without Resolution A Privacy-Friendly
 * Revocation Mechanism for Vehicular Ad-Hoc Networks by David
 * Forster, Hans Lohr, Jan Zibuschka, and Frank Kargl
 *
 * Purpose: Formal Model of R-Token revocation REWIRE variant
 *
 * Results:
 * Failure to meet authentication properties. Meets lemmas G1, G5 and
 * G6
 *
 * Model Name: REWIRE_plain.spthy
 * Status: STABLE
 */

theory REWIRE_PLAIN
begin

builtins:   asymmetric-encryption, signing


/* Restrictions */


// Under perfect cryptography assumption all checks must succeed
restriction equality_checks_succeed:
"All x y #i. Eq( x, y ) @ i ==> x = y"


/* Key initialisation restrictions */

// Restricts the RA key setup event to occur only once
restriction single_RA:
"All #i #j. SetupRevAuthKeys( ) @ i & SetupRevAuthKeys(  ) @ j ==> #i = #j"


// Restricts a Vj long-term key setup event to occur only once
restriction single_Ltk_setup:
"All id #i #j. SetupVehicleLtk( id ) @ i & SetupVehicleLtk( id ) @ j ==> #i = #j"


// Restricts a Vj pseudonym key setup event to occur only once
restriction single_psi_init:
"All id #i #j. InitPSiKey( id ) @ i & InitPSiKey( id ) @ j ==> #i = #j"


/* Restrictions representing non key leak */


// The RA is a trusted third party and the key cannot be leaked.
restriction no_ra_leak:
"not ( Ex id key #i #j . SetupRAKeys( id, key ) @ #i & K( key ) @ #j )"


// PROTOCOL START ----------------------------------------------------


/* Key Setup */


// Establish the long term key pair of the Revocation Authority (RA)
rule RA_SETUP:
let
  PK_RA = pk( ~SK_RA )
in
    [ Fr( ~SK_RA )  ]
  --[ SetupRevAuthKeys(  ), SetupRAKeys( $RA, ~SK_RA ) ]->
    [
        !RevAuthSK( $RA, ~SK_RA )
      , !RevAuthPK( $RA, PK_RA )
      , Out( PK_RA )
    ]


// Setup the long-term symmetric key of vehicle $Vj
rule SETUP_VEHICLE_LTK:
    [ Fr( ~Ltk ) ]
  --[
        SetupVehicleLtk( $Vj )
      , VehicleSetup( $Vj, ~Ltk )
    ]->
    [ !Ltk( $Vj, ~Ltk ) ]


// Reveal the long-term key pair of $Vj
rule REVEAL_VEHICLE_LTK:
    [ !Ltk( $Vj, Ltk ) ]
  --[
        VehicleCompromised( $Vj, Ltk )
      , RevealLtk( $Vj )
    ]->
    [ Out( Ltk ) ]


// Asymmetric pseudonym key pair for Vj
rule SETUP_PSI_KEY:
  let
    PK_PSi = pk( ~SK_PSi )
  in
    [ Fr( ~SK_PSi ) ]
  --[ InitPSiKey( $Vj ) ]->
    [
        !VehiclePSi( $Vj, ~SK_PSi )
      , !VehiclePKPSi( $Vj, PK_PSi )
      , CanChange( $Vj, ~SK_PSi )
    ]


// Reveal asymmetric pseudonym key pair for Vj
rule REVEAL_PSI_KEY:
    [ !VehiclePSi( $Vj, SK_PSi )  ]
  --[
        VjSKPSiReveal( $Vj, SK_PSi )
      , RevealSKPSi( $Vj )
    ]->
    [ Out( SK_PSi ) ]


// Changes the current pseudonym of Vj
rule CHANGE_PSEUDONYM:
  let
    old_PK_PSi = pk( old_SK_PSi )
    PK_PSi = pk( ~SK_PSi )
  in
    [
        Fr( ~SK_PSi ),
        CanChange( $Vj, old_SK_PSi )
    ]
  --[ ChangePseudonymForVehicle( $Vj, old_PK_PSi, PK_PSi ) ]->
    [
        !VehiclePSi( $Vj, ~SK_PSi )
      , CanChange( $Vj, ~SK_PSi )
      , Out( PK_PSi )
    ]


// Creates report to RA, beginning the revocation process
rule REPORT:
  let
    PK_PSi = pk( SK_PSi )
  in
    [ !VehiclePKPSi( $Vj, PK_PSi ) ]
  --[ Reported( $Vj, PK_PSi ), HasReport( $Vj ) ]->
    [ Report( $Vj, PK_PSi ) ]


/* Revocation Protocol
 * RA -> Vj : osr-req := {| 'revoke', PK_PSi, 'reason' |}PK_RA
 * Vj       : Verify osr-req
 * Vj -> RA : osr-conf := {| 'confirm', PK_PSi |}SK_PSi
 */


rule OSR_REQ_SEND:
  let
    PK_PSi      = pk( SK_PSi )
    osrReq      = < 'revoke', PK_PSi, 'reason' >
    osrReqSig   = sign( osrReq, SK_RA )
    osrReqMsg   = < $RA, $Vj, osrReq, osrReqSig >
  in
    [
        Report( $Vj, PK_PSi )
      , !RevAuthSK( $RA, SK_RA )
    ]
  --[
        OsrReqMsgSentTo( $RA, $Vj, PK_PSi )
      , Send($RA, osrReqMsg)
      , Running( $Vj, $RA, osrReqMsg )
    ]->
    [
        AwaitRevokeConfirmation( $RA, $Vj, PK_PSi, SK_RA )
      , Out( osrReqMsg )
    ]


rule OSR_REQ_RECV:
  let
    PK_PSi      = pk( SK_PSi )
    osrReq      = < 'revoke', PK_PSi, 'reason' >
    osrReqSig   = sign( osrReq, SK_RA )
    osrReqMsg   = < $RA, $Vj, osrReq, osrReqSig >
    osrConf     = < $Vj, 'confirm', PK_PSi >
    osrConfSig  = sign( osrConf, SK_PSi )
    osrConfMsg  = < $Vj, $RA, osrConf, osrConfSig >
  in
    [
        In( osrReqMsg )
      , !RevAuthPK( $RA, PK_RA )
      , !VehiclePSi( $Vj, SK_PSi )
      , CanChange( $Vj, SK_PSi )
    ]
  --[   Commit( $RA, $Vj, osrReqMsg )
      , OsrReqMsgRecvBy( $Vj, $RA, PK_PSi )
      , Recv($Vj, osrReqMsg)
      , Eq( verify( osrReqSig, osrReq, PK_RA ), true )
      , OsrReqVerified( $Vj, PK_PSi )
      , Running( $RA, $Vj, osrConfMsg )
      , OsrConfSentBy( $Vj, $RA, PK_PSi )
    ]->
    [ Out( osrConfMsg ) ]


rule REV_AUTH_OSR_CONF_RECV:
 let
    PK_PSi      = pk( SK_PSi )
    osrConf     = < $Vj, 'confirm', PK_PSi >
    osrConfSig  = sign( osrConf, SK_PSi )
    osrConfMsg  = < $Vj, $RA, osrConf, osrConfSig >
  in
    [
        In( osrConfMsg )
      , AwaitRevokeConfirmation( $RA, $Vj, PK_PSi, SK_RA )
    ]
  --[
        Commit( $Vj, $RA, osrConfMsg )
      , Eq( verify( osrConfSig, osrConf, PK_PSi ), true )
      , OsrConfAcceptedBy( $RA, $Vj, PK_PSi )
    ]->
    [  ]


// PROTOCOL END ------------------------------------------------------


/* Functional Correctness Lemmas */


/*
 * Proof Goal G1
 *    Sanity check of the protocol to ensure correct execution
 */
lemma executable:
  exists-trace
    "/* It should be possible that when an osr-req is sent it's received */
      Ex id_ra id_vj m t #i #j #k .
        Send(id_ra, m) @ #i
      & Recv(id_vj, m) @ #j
      /* and the OSR-Conf is accepted by the RA */
      & OsrConfAcceptedBy( id_ra, id_vj, t ) @ #k
      /* such that the OSR-Req is sent, received and then accepted */
      & #i < #j
      & #j < #k
    "


/*
 * Proof Goal G2
 *    This lemma states that if a vehicle Vj changes its pseudonym and a previous
 *    pseudonym is revoked, it should be possible for the vehicle to create an
 *    OSR-Conf message
 */
lemma revoke_after_change_exists:
  exists-trace
  "/* It should be possible that when a report for Vj is made with pseudonym 1 (t1) */
    ( Ex id_vj ps1 ps2 id_ra #i #j #k .
        Reported( id_vj, ps1 ) @ #i
        /* and there has been a change of pseudonym from t1 to t2 */
        & ChangePseudonymForVehicle( id_vj, ps1, ps2 ) @ #j
        /* and an OSR-Conf should be sent after the change occurred */
        & OsrConfSentBy( id_vj, id_ra, ps1 ) @ #k
        /* and the report occurred before the change to t2 */
        & #i < #j
        /* and the change occurs prior to the confirmation*/
        & #j < #k
        /* and the adversary did not perform a long-term / pseudonym key reveal on Vj  */
         & not( Ex k #n. VehicleCompromised( id_vj, k ) @ #n )
         & not( Ex k #n . VjSKPSiReveal( id_vj, k ) @ #n )
  )
  "

/* Authentication Lemmas */


/*
 * Proof Goal G5
 *    Weak agreement is a form of authentication which guarantees that when the
 *    RA completes a run of the protocol it guarantees that it was
 *    interacting with the Vj who had also been running the protocol.
 */
lemma weak_agreement:
   " /* If there was an RA that accept an OSR-Conf message from a vehicle with pseudonym t */
    All id_vj id_ra t #i.
        OsrConfAcceptedBy( id_ra, id_vj, t ) @ i
     /* Then there exists a vehicle with the pseudonym t who received the OSR-Req */
     ==>  ( Ex t2 #j. OsrReqMsgRecvBy( id_vj, id_ra, t2 ) @ j )
          /* or the adversary perform a long-term key / pseudonym key reveal on the vehicle */
          | ( Ex #r. RevealLtk( id_vj )   @ r )
          | ( Ex #r. RevealSKPSi( id_vj ) @ r )
   "


/*
 * Proof Goal G6
 *    Non-injective agreement guarantees that the RA and vehicle Vj each agree upon
 *    the completion of a run with each other and that in those runs the contents
 *    of the received messages correspond to the sent messages.
 */
lemma noninjective_agreement:
  all-traces
  " /* Whenever a vehicle or RA commits to running a session, then */
    All a b msg #i.
      Commit( a, b, msg ) @ i
    /* there is RA / vehicle running a session with the same parameters */
    ==> ( Ex #j. Running( b, a, msg ) @ j )
        /* or the adversary perform a long-term key / pseudonym key reveal on the vehicle */
        | ( Ex C #r. RevealLtk( C ) @ r )
        | ( Ex C #r. RevealSKPSi( C ) @ r )
  "


/*
 * Proof Goal G7
 *    Non-injective synchronisation is very similar to non-injective agreement
 *    but additionally requires that the corresponding send and receive messages
 *    have to be executed in their expected order.
 */
lemma noninjective_synchronisation:
  all-traces
    "/* If there was an RA that accept an OSR-Conf message from a vehicle with pseudonym t */
    ( All id_ra id_vj ps #i .
        OsrConfAcceptedBy( id_ra, id_vj, ps ) @ #i
        /* and the adversary perform a pseudonym key reveal on the vehicle */
         & not( Ex k1 #q . VjSKPSiReveal( id_vj, k1 ) @ #q )
        /* Then there exists a vehicle with the pseudonym t who received the OSR-Req */
  ==> ( Ex #l . OsrReqMsgRecvBy( id_vj, id_ra, ps ) @ #l
        /* such that OSR-Req was received before a OSR-Conf is accepted by the RA */
        & #l < #i ) )
    "


end
